# phishing_testing

Краткая документация, отражающая текущее поведение проектных файлов.

**Ключевые файлы и поведение**
- Сборка: [scripts/build.sh](scripts/build.sh#L1) — интерактивный Bash-скрипт. Скрипт запрашивает значения (включая `SECRET_KEY` и `ADMIN_PASS`), затем вызывает `docker build` с передачей этих значений через `--build-arg` и помечает образ тегом `phishing-dashboard:1.0`.
- Обновление: [scripts/update.sh](scripts/update.sh#L1) — подтягивает код из Git, читает/использует сохранённые значения из `.build_defaults` (если есть), собирает образ с `--build-arg`, сохраняет/восстанавливает `phishing_data.db` на хосте, корректно останавливает и удаляет старый контейнер и запускает новый.
- Dockerfile: [Dockerfile](Dockerfile#L1) содержит `ARG` и затем `ENV` для тех же значений (включая `SECRET_KEY`) — это означает, что по текущей реализации секреты могут оказаться в слоях образа.
- Конфигурация приложения: [config.py](config.py#L1) читает `SECRET_KEY` из переменных окружения (с запасным значением по умолчанию).
- Инициализация пользователей: [db.py](db.py#L1) при отсутствии пользователей создаёт администратора, беря `ADMIN_USER` и `ADMIN_PASS` из окружения.

Важно: текущее поведение (передача секретов через `--build-arg` и запись в `ENV`) делает сборку удобной, но небезопасной — Docker может показывать предупреждения о том, что секреты попадают в слои образа. Если вы хотите избежать этого, рекомендуется передавать секреты в рантайме (через `-e` / монтирование файлов / Docker secrets) и не использовать `--build-arg` для чувствительных данных.

## Быстрый старт (актуально для текущей реализации)

1) Клонировать репозиторий:

```bash
git clone https://github.com/v019f1n9er/phishing_testing.git
cd phishing_testing
```

2) Собрать образ (рекомендуется использовать скрипт):

```bash
./scripts/build.sh
```

Скрипт запишет выбранные значения в файл `.build_defaults` в корне репозитория — он используется скриптом обновления. Обратите внимание: по текущей реализации `SECRET_KEY` и `ADMIN_PASS` также передаются как `--build-arg` и будут записаны в `.build_defaults`.

3) Запустить контейнер (пример):

```bash
docker run -d -p 8080:8080 --name phishing-dashboard-container \
  -v "$PWD/phishing_data.db:/app/phishing_data.db:rw" \
  phishing-dashboard:1.0
```

Если вы передавали секреты при сборке, они уже будут присутствовать в образе/контейнере в соответствии с текущим `Dockerfile`.

## Обновление без потери данных

Для обновления используйте скрипт:

```bash
./scripts/update.sh
```

Поведение `update.sh` (текущее):
- выполняет `git pull`;
- читает `.build_defaults` (если есть) и предлагает значения как дефолты при интерактивном вводе;
- пытается скопировать `phishing_data.db` из существующего контейнера на хост, если файла нет;
- собирает образ с `--build-arg` и перезапускает контейнер, сохраняя хостовый файл `phishing_data.db` через bind-mount.

## Безопасность — что учитывать
- Текущая реализация использует `ARG`/`ENV` и `--build-arg` для передачи секретов. Docker может выводить предупреждения типа "SecretsUsedInArgOrEnv" — это ожидаемо. Чтобы убрать риск утечки секретов в слоях образа, рассмотрите альтернативы:
  - хранить секреты вне репозитория и монтировать их в контейнер в рантайме (например, `/run/secrets/*`),
  - использовать Docker secrets (в Docker Swarm),
  - передавать только небезопасные параметры как env при запуске, а чувствительные хранить в защищённых хранилищах.

## Где смотреть
- Основной запуск и сборка: [scripts/build.sh](scripts/build.sh#L1)
- Обновление и рестарт: [scripts/update.sh](scripts/update.sh#L1)
- Dockerfile: [Dockerfile](Dockerfile#L1)
- Конфигурация: [config.py](config.py#L1)
- Инициализация пользователей: [db.py](db.py#L1)

Если хотите, могу обновить реализацию сборки/запуска так, чтобы секреты не попадали в образ (см. варианты в разделе "Безопасность"), и затем снова привести `README.md` к более безопасному примеру запуска.
